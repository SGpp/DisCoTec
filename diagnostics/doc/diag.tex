\documentclass[12pt]{article}

\begin{document}


\section{Global variables}

All global variables can be found in
\texttt{internal/global\_vars.pro}:

\subsection{\texttt{gui}}

This variable contains all information that need to be passed from
the GUI to the mom/field loop (\texttt{gui.out}), as well as all
information exclusively used by the GUI.

\subsection{\texttt{series}}

A series comprises a number of connected runs which operate in the
same physical scenario. In the strictest sense, all physical and
numerical parameters have to be identical. In reality, single
parameters can be changed during the course of a series, but
extreme caution has to be applied when interpreting the results of
such simulations. The series structure includes all information
which is specific to one series.

\subsection{\texttt{par}}

All relevant information except the species specific variables
declared in the \texttt{parameters} file is stored here.

\subsection{\texttt{spec}}

Here, one can find the species specific definitions.

\subsection{\texttt{nrg}, \texttt{mom}, \texttt{vsp}}

These contain all nrg steps of the series, and the most recent
mom or vsp step, respectively. For the mom/field data, 
fourier transformed versions are provided if requested by 
diagnostic programs.
Pointers are necessary, for during the runtime, changing the
series will likely change the size of the arrays stored here.

\subsection{\texttt{diag0}, \texttt{cdiag0}}

Those pointers point at the first (custom) diagnostic in the
diagnostics list. From there, one reaches the second diagnostic
via the pointer \texttt{next}, and so forth.

\subsection{\texttt{file\_mom (\_field, \dots)}}

Both the existence and the path to the corresponding files is
stored here. Please note that in the data loop, a run that is no
longer required for data input may be dubbed nonexistent when the
file still exists.

\subsection{\texttt{vm\_sav}}

This variable serves for distinguishing purposes where Virtual
Machine specific structures are concerned.


\section{The file structure}

\subsection{\texttt{diagnostics} (main directory)}

The only file in this directory is \texttt{diag.pro}. This is the
main batch file, to be called via \texttt{@diag}. If one wishes to
enter a more verbatim mode, the system variable \texttt{!QUIET}
can be set to zero, resulting in more elaborate output. In case
the user utilizes the Virtual Machine version of the diagnostic,
she or he must start the \texttt{vm\_diag.sav} file, instead.

\subsection{\texttt{internal}}

This folder contains the procedures and functions used by the
diagnostic. More specifically, the GUI, the structures e.g. 
of the nrg and field/mom data, as well as the general 
handling of the diagnostics files can be found here.

\subsection{\texttt{prog}}

Here, multiple diagnostics are located which can be used to
produce data or postscript output. Any \texttt{.pro} file in this
directory must include a certain pattern of routines compatible
with the main diagnostic. Help texts for the diagnostic are
included at the beginning of the file in the form of commented
lines.

\subsection{\texttt{custom}}

In this folder, the user can administrate his or her own
diagnostics. These diagnostics are recompiled whenever the
\emph{save and start} button in clicked. This allows the user to
edit the custom diagnostic while leaving the GUI open. Two aspects
shall be mentioned that require some caution: First, every file in
this folder that ends with \texttt{.pro} and does not start with
\texttt{.} will be compiled by the diagnostic. Second, every
custom diagnostic has to have a procedure name identical to the
file name, without the file ending. An example is shown in
\texttt{ctest1.pro}. Be aware that no comment lines are allowed in
the file header (before the init procedure).

\subsection{\texttt{output}}

Any output, be it data or postscript, will be saved into this
directory, unless the user provides a different location in the
GUI. If the specified folder does not exist, it is created.

\subsection{\texttt{doc}}

The documentation, consisting of this pdf file and the
corresponding TeX file, can be found here.


\section{The data loops}

Once the user has selected a number of diagnostic programs with
corresponding sets of parameters, and starts the diagnostic, the
so-called data loop for the current tab is started. 
This will cause the following pattern to be executed:

\begin{itemize}
\item Executing (and for cdiags, recompiling) all selected
(custom) diagnostic program init parts (see below); gathering
information on which variables are to be read in which fourier
states. \item Create the appropriate data structure for the data
pointer to contain the variables with their fourier transforms;
prepare interleaving e.g. for different \texttt{istep\_field} and
\texttt{istep\_mom}. \item Now, a loop over all runs is started --
if a run is not in the time range, it is omitted. \item After
reading time and double fourier data, FFTs are performed to
completely fill the data pointer. \item Next, the loop parts of
the diagnostic programs are executed. \item After the main loop is
finished (the program has gone through all runs), the data files
are closed and the output procedures called.
\end{itemize}


\section{Integrate user written diagnostics}

\subsection{Introduction}

Each diagnostic has to be stored in his own pro file. The name of
the file must be the same as the basic name of the diagnostic. The
scheme of calling a diagnostic is fixed and cannot be changed.
During the initialization of the GUI the \texttt{info} function is
called to register the diagnostic (title, helptext etc.) 
into the GUI table.
If \texttt{save\&start} has been invoked, the \texttt{init} procedure 
is called, where the function has to register its internal variables 
and do all necessary calculations to initialize these variables. 
Then the loop over all selected time steps is started, and for each
time step the \texttt{loop} procedure is called. This part can use the
registered global variables and should do all calculations based
on time step data. After processing all time steps, the
\texttt{output} procedure is called. The diagnostic should create
output both in postscript and raw data format. If the init
procedure has used pointers within its internal variables, these
have to be freed in the output procedure.

\subsection{The \texttt{info} function}

The \texttt{info} function returns a data structure containing the type (e.g. 
mom, nrg, vsp, etc.), the title which should appear in the GUI 
table, a helptext and an array of so called external variables 
which are used to transfer information from the GUI table to your
user written diagnostic. Each entry of the external variables array 
consists of the variable name (string), the variable type (0 for 
array of numbers, 1 for on/off switch) and a description.\\
Example:
\begin{verbatim}
FUNCTION [name]_info, diagpointer
  RETURN, {$
    type      : 'mom',$
    title     : 'My diag',$
    help_text : ['This is a very useful diag.'],$
    ext_vars  : [['var1','0','index of the fluctuating '+$
                  'quantity to be plotted (see variable list)'],$
                 ['switch','1','switch on/off']]}
END
\end{verbatim}

\subsection{The \texttt{init} procedure}

Procedure definition has to be:
\begin{verbatim}
PRO [name]_init, diagpointer
\end{verbatim}
where \texttt{diagpointer} is the pointer to this diagnostic
(supplied by the main program). To access the previously defined
external variables which should usually be processed in the \texttt{init} 
part, you need to include the following line 
\begin{verbatim} 
  e = (*diagpointer).external_vars
\end{verbatim}
After that they are simply available via
\begin{verbatim} 
  *e.<var_name as defined in info part>  
\end{verbatim}
Please substitute default values if necessary to avoid program crashes
due to undefined variables, e.g.
\begin{verbatim} 
  IF N_ELEMENTS(*e.vars) LT 1 THEN *e.vars = [0,2]
\end{verbatim}

To access global variables, e.g. the par structure, the first line should
be
\begin{verbatim}
COMMON global_vars
\end{verbatim}

For private variables, which shall be used within all parts/procedures of
your diagnostic, a so called internal structure has to be registered.
This can be done by calling the function:
\begin{verbatim}
i = set_internal_vars(diagpointer,{$
  variable_1 : [value],$
  ...
  variable_n : [value]})
\end{verbatim}

where {\tt diagpointer} points to the diagnostic structure, variable\_1
to variable\_n are the diagnostic specific internal variables and {\tt i}
is the resulting pointer to the created internal structure. \\

If the diagnostic type is \texttt{mom} you need to declare which {\tt mom}
and {\tt field} variables will be used by your diagnostic and whether
fourier transformations have to be performed. This can be done using the
function
\begin{verbatim}
fft_format, kxky=[var1,...,varn], sxky=..., kxsy=...,
sxsy=...
\end{verbatim}
The variable numbers depend on the currently used field and mom file
structure and can be found by clicking the gui button {\tt variable list}.


\subsection{The \texttt{loop} procedure}

Procedure definition has to be:
\begin{verbatim}
PRO [name]_loop, diagpointer
\end{verbatim}

This procedure will be called for each simulation time step. If global
parameters are needed, include the following line
\begin{verbatim}
COMMON global_vars
\end{verbatim}
To access the diagnostic wide private variables (see above), type
\begin{verbatim}
i = (*diagpointer).internal_vars
\end{verbatim}
Since {\tt i} is a pointer, certain variables are called by e.g.
\begin{verbatim}
(*i).variable_1
\end{verbatim}
The current step time is stored in {\tt <diagnostic type>\_time} 
(e.g. mom\_time) and the requested data arrays can be used by e.g.
\begin{verbatim}
(*mom[variable_index,species_index].kxky)[*,*,*]
\end{verbatim}
where {\tt species\_index} is the index of the species to be
analyzed (with respect to all selected species - the parameter
namelist index can be calculated using {\tt
(*gui.out.spec\_select)[species\_index]}), {\tt kxky} ({\tt sxky},
{\tt kxsy}, {\tt sxsy}) specifies the fft type and {\tt
variable\_index} is the index of variable to be used. The three
stars will extract all grid points in all three dimensions. Of
course, single points or ranges can be extracted as well.

\subsection{The \texttt{output} procedure}

The procedure definition has to be:
\begin{verbatim}
PRO [name]_output, diagpointer
\end{verbatim}
Global and private variables can be accessed as described in the
{\tt loop} part. The  total number of time steps can be found in
{\tt series.step\_time}. Before plot commands are invoked, you
need to call
\begin{verbatim}
set_output, diagpointer, species_index, /ps
\end{verbatim}
to open a postscript file. To specify which variable should be
written if the user selects data output instead of or along with
postscript, specify
\begin{verbatim}
set_output, diagpointer, species_index, dat=variable_to_be_written
\end{verbatim}
Postscript and data files will be closed by
\begin{verbatim}
set_output, diagpointer, species_index, /reset
\end{verbatim}
The postscript files will then be modified to contain the
diagnostic program's title.

\section{Intrinsic time averaging}
Most of the diagnostics calculate and plot time averaged quantities.
For this purpose, a special function \texttt{time\_avg} is provided 
which takes into account adaptive time steps and 
shall be used in the following way:
\begin{itemize}
\item add a pointer to your internal variables in the \texttt{init} part,
e.g. 
\begin{verbatim}
i = set_internal_vars(diagpointer,{$
  ...
  mydata_id : PTR_NEW()})
\end{verbatim}
%
\item call the \texttt{time\_avg} function at the end of your 
\texttt{loop} part, e.g.
\begin{verbatim}
  (*i).mydata_id = time_avg((*i).mydata_id,local_data,mom_time)
\end{verbatim}
where \texttt{local\_data} is the (locally computed) quantity 
to be averaged and \texttt{mom\_time} the current time.
\item use e.g.
\begin{verbatim}
  mydata = time_avg((*i).mydata_id,/avg)
\end{verbatim}
in the \texttt{output} part to store the time averaged value
in \texttt{mydata}.
\end{itemize}

\section{The Graphical User Interface (GUI)}
Please consult the main {\sc GENE} documentation.
\end{document}
